#!/usr/bin/env python3
"""
File: signalLinkThread.py
    Run the link process in a separate Thread.
"""
import curses
import json
import logging
import subprocess
import threading
import socket
from typing import Callable, Optional, Any

from .signalAccount import SignalAccount
from .signalAccounts import SignalAccounts
from .signalCommon import (__socket_create__, __socket_connect__, __socket_close__, __socket_send__,
                           __parse_signal_response__, __check_response_for_error__, __type_error__, __find_qrencode__,
                           LinkAccountCallbackStates, __socket_receive_non_blocking__)

from .runCallback import __run_callback__, __type_check_callback__
from .signalExceptions import CommunicationsError


class SignalLinkThread(threading.Thread):
    """
    The linking thread.
    """

    def __init__(self,
                 server_address: tuple[str, int] | str,
                 accounts: SignalAccounts,
                 callback: tuple[Callable, Optional[list[Any] | tuple[Any, ...]]],
                 gen_text_qr: bool = True,
                 png_qr_file_path: Optional[str] = None,
                 device_name: Optional[str] = None,
                 wait_time: float = 0.25,
                 ) -> None:
        """
        Initialize the SignalLinkThread.
        :param server_address: tuple[str, int] | str: The server address to connect to.
        :param accounts: SignalAccounts: The loaded signal accounts.\\ll
        :param callback: tuple[Callable, Optional[list[Any] | tuple[Any, ...]]]: The call back to call for status
            updates.
        :param gen_text_qr: bool: Should we generate a text qr-code?
        :param png_qr_file_path: Optional[str]: Path to the png qr-code file. If None, the qr-code is not generated.
        :param device_name: Optional[str]: The device name. If None, the default set by signal-cli is used.
        :param wait_time: float: The amount of time to give the socket to respond.
        """
        # Super the thread.
        super().__init__(None)
        logger: logging.Logger = logging.getLogger(__name__ + '.' + self.__init__.__name__)

        if not isinstance(server_address, (tuple, str)):
            logger.critical("Raising TypeError:")
            __type_error__('server_address', 'tuple[str, int] | str', server_address)

        if not isinstance(accounts, SignalAccounts):
            logger.critical("Raising TypeError:")
            __type_error__('accounts', "SignalAccounts", accounts)

        if not __type_check_callback__(callback)[0]:
            logger.critical("Raising TypeError:")
            __type_error__("callback", "tuple[Callable, Optional[list[Any] | tuple[Any, ...]]]",
                           callback)

        if not isinstance(gen_text_qr, bool):
            logger.critical("Raising TypeError:")
            __type_error__('gen_text_qr', 'bool', gen_text_qr)

        if png_qr_file_path is not None and not isinstance(png_qr_file_path, str):
            logger.critical("Raising TypeError:")
            __type_error__("png_qr_file_path", 'Optional[str]', png_qr_file_path)

        if device_name is not None and not isinstance(device_name, str):
            logger.critical("Raising TypeError:")
            __type_error__("device_name", "Optional[str]", device_name)

        if not isinstance(wait_time, float):
            logger.critical("Raising TypeError:")
            __type_error__("wait_time", 'float', wait_time)

        # Private properties:
        self._accounts: SignalAccounts = accounts
        """The loaded accounts object."""
        self._callback: Optional[tuple[Callable, Optional[list[Any] | tuple[Any, ...]]]] = callback
        """The call back to run."""
        self._gen_text_qr: bool = gen_text_qr
        """Should we generate a text qr code?"""
        self._png_qr_file_path: Optional[str] = png_qr_file_path
        """The file path to the png qrcode we generate."""
        self._device_name: Optional[str] = device_name
        """The device name to link with"""
        self._wait_time: float = wait_time
        """The waiting time for signal to respond."""

        self._qrencode_exec_path: Optional[str] = __find_qrencode__()
        """The exec path of qrencode utility."""
        self._link_uri: Optional[str] = None
        """The link uri generated by signal."""
        self._text_qr: Optional[str] = None
        """The generated text qr-code."""
        self._is_cancelled: bool = False
        """Has this link been canceled?"""
        self._complete: bool = False
        """Is the link process complete?"""
        # Create and connect to the link socket:
        self._link_socket: socket.socket = __socket_create__(server_address)
        """The socket to run the link process on."""
        __socket_connect__(self._link_socket, server_address)
        return

    def __call_callback__(self,
                          status: LinkAccountCallbackStates,
                          data: Optional[tuple[Optional[str], Optional[str]] | str | SignalAccount],
                          ) -> Optional[Any]:
        """
        Call the callback with the given status and data.
        :param status: LinkCallbackStates: The callback status codes.
        :param data: Optional[str | SignalAccount],
        :return: Optional[Any]: The return value of the callback.
        """
        return __run_callback__(self._callback, status.value, data)

    def run(self) -> None:
        """
        Start the linking process.
        :return: None.
        """
        # Setup logging:
        logger: logging.Logger = logging.getLogger(__name__ + '.' + self.start.__name__)

        # Check if the socket has been used up:
        if self._is_cancelled or self._complete:
            error_message: str = "Socket has been closed."
            logger.critical("Raising RuntimeError(%s)." % error_message)
            raise RuntimeError(error_message)

        # Start by calling the callback to state we're generating the link:
        logger.debug("Calling generate URI start callback.")
        return_value: Optional[bool] = self.__call_callback__(LinkAccountCallbackStates.GENERATE_URI_START, None)
        if return_value is True:
            self.cancel()
            return

        # Create the link start request object:
        link_start_command_obj: dict[str, Any] = {
            'jsonrpc': '2.0',
            'id': 0,
            'method': 'startLink',
        }

        # Create the JSON command string:
        json_command_str: str = json.dumps(link_start_command_obj) + '\n'

        # Communicate with signal:
        __socket_send__(self._link_socket, json_command_str)
        # Receive loop:
        try:
            response_str: Optional[str] = None
            first_loop: bool = True
            while response_str is None:
                if not first_loop:
                    logger.debug("Calling waiting callback.")
                    return_value = self.__call_callback__(LinkAccountCallbackStates.LINK_WAITING, None)
                    if return_value is True:
                        self.cancel()
                        return
                first_loop = False
                response_str = __socket_receive_non_blocking__(self._link_socket, self._wait_time)
        except CommunicationsError as e:
            if self._is_cancelled:
                return
            raise e

        response_obj: dict[str, Any] = __parse_signal_response__(response_str)
        __check_response_for_error__(response_obj)

        # Store the link URI:
        self._link_uri: str = response_obj['result']['deviceLinkUri']

        # Call the link generation complete:
        logger.debug("Calling generate URI stop callback.")
        return_value = self.__call_callback__(LinkAccountCallbackStates.GENERATE_URI_STOP, self._link_uri)
        if return_value is True:
            self.cancel()
            return

        # Call the qr-code generate start callback:
        if self._qrencode_exec_path is not None and (self._gen_text_qr or self._png_qr_file_path is not None):
            return_value = self.__call_callback__(LinkAccountCallbackStates.GENERATE_QR_START, None)
            if return_value is True:
                self.cancel()
                return

        # Generate the text qr-code:
        if self._qrencode_exec_path is not None and self._gen_text_qr:
            command_line: list[str] = [self._qrencode_exec_path, '-o', '-', '--type=UTF8', '-m', '1', self._link_uri]
            logger.debug("Attempting to generate qr-code...")
            try:
                bytes_qr_code: bytes = subprocess.check_output(command_line)
                text_qr_code: str = bytes_qr_code.decode('UTF8')
                # Add missing border to qr-code:
                border_string: str = '\u2584' * len(text_qr_code.splitlines(keepends=False)[0])
                self._text_qr = border_string + '\n' + text_qr_code
                logger.debug("text qr-code successfully generated.")
            except subprocess.CalledProcessError:
                error_message: str = "Failed to generate UTF8 qr-code."
                logger.critical("Raising RuntimeError(%s)." % error_message)
                raise RuntimeError(error_message)

        # Generate the png qr-code:
        if self._qrencode_exec_path is not None and self._png_qr_file_path is not None:
            logger.debug("Attempting to generate png qr-code.")
            try:
                subprocess.check_call([self._qrencode_exec_path, '-o', self._png_qr_file_path, self._link_uri])
                logger.debug("Successfully generated png qr-code.")
            except subprocess.CalledProcessError:
                error_message: str = "Failed to generate png qr-code."
                logger.warning("Raising RuntimeError(%s)." % error_message)
                raise RuntimeError(error_message)

        # Call the qr-code generate finished callback:
        if self._qrencode_exec_path and (self._gen_text_qr or self._png_qr_file_path is not None):
            return_value = self.__call_callback__(LinkAccountCallbackStates.GENERATE_QR_STOP, (self._text_qr,
                                                                                               self._png_qr_file_path))
            if return_value is True:
                self.cancel()
                return

        # Create the finish link command object:
        link_finish_command_obj: dict[str, Any] = {
            'jsonrpc': '2.0',
            'id': 1,
            'method': 'finishLink',
            'params': {
                'deviceLinkUri': self._link_uri,
            }
        }
        if self._device_name is not None:
            link_finish_command_obj['params']['deviceName'] = self._device_name

        # Create the JSON command string:
        json_command_str = json.dumps(link_finish_command_obj) + '\n'
        logger.debug("Sending finishLink command.")
        # Send the command to signal:
        __socket_send__(self._link_socket, json_command_str)

        # Call the call back for finish started:
        return_value = self.__call_callback__(LinkAccountCallbackStates.FINISH_START, None)
        if return_value is True:
            self.cancel()
            return

        # Wait for signal response:
        response_str = None
        try:
            first_loop: bool = True
            while response_str is None:
                if not first_loop:
                    logger.debug("Waiting for signal.")
                    return_value = self.__call_callback__(LinkAccountCallbackStates.LINK_WAITING, None)
                    if return_value is True:
                        self.cancel()
                        return
                first_loop = False
                response_str = __socket_receive_non_blocking__(self._link_socket, self._wait_time)
        except CommunicationsError as e:
            if self._is_cancelled:
                return
            raise e
        response_obj = __parse_signal_response__(response_str)

        # Check for error:
        error_occurred, signal_code, signal_message = __check_response_for_error__(response_obj, [-1, -2, -3])
        if error_occurred:
            if signal_code == -1:
                logger.debug("Calling exists error callback.")
                self.__call_callback__(LinkAccountCallbackStates.LINK_EXISTS_ERROR, signal_message)
            elif signal_code == -2:
                logger.debug("Calling unknown error callback.")
                self.__call_callback__(LinkAccountCallbackStates.LINK_UNKNOWN_ERROR, signal_message)
            elif signal_code == -3:
                logger.debug("Calling timeout error callback.")
                self.__call_callback__(LinkAccountCallbackStates.LINK_TIMEOUT_ERROR, signal_message)
            self.cancel()
            return

        # Link successful:
        linked_number: str = response_obj['result']['number']
        logger.debug("Link successful for account: %s" % linked_number)

        new_accounts = self._accounts.__sync__()
        if len(new_accounts) == 0:
            error_message: str = "Unable to find new account."
            logger.critical("Raising RuntimeError(%s)." % error_message)
            raise RuntimeError(error_message)

        # Call callback with success, and account.
        self.__call_callback__(LinkAccountCallbackStates.LINK_SUCCESS, new_accounts[0])
        __socket_close__(self._link_socket)
        self._complete = True
        return

    def cancel(self) -> None:
        """
        Cancel a currently running link.
        :return: None.
        """
        self._is_cancelled = True
        __socket_close__(self._link_socket)
        self.__call_callback__(LinkAccountCallbackStates.LINK_CANCELED, None)
        return

#####################################
# Properties:
#####################################
    @property
    def is_complete(self) -> bool:
        """
        Is the link complete?
        :return: bool: True the link is complete, False it is not.
        """
        return self._complete

    @property
    def is_canceled(self) -> bool:
        """
        Has the link been cancelled?
        :return: bool: True, the link has been cancelled, False, it has not.
        """
        return self._is_cancelled
