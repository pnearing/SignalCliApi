#!/usr/bin/env python3
"""
File: signalLinkThread.py
    Run the link process in a separate Thread.
"""
import json
import logging
import subprocess
import threading
import socket
from typing import Callable, Optional, Any

from .signalAccount import Account
from .signalAccounts import Accounts
from .signalCommon import (__socket_create__, __socket_connect__, __socket_close__, __socket_send__,
                           __parse_signal_response__, __check_response_for_error__, __type_error__, __find_qrencode__,
                           LinkAccountCallbackStates, __socket_receive_non_blocking__)

from .runCallback import __run_callback__, __type_check_callback__
from .signalExceptions import CommunicationsError


class LinkThread(threading.Thread):
    """
    The linking thread.
    """

    def __init__(self,
                 server_address: tuple[str, int] | str,
                 accounts: Accounts,
                 callback: tuple[Callable, Optional[list[Any] | tuple[Any, ...]]],
                 ) -> None:
        """
        Initialize the LinkThread.
        :param server_address: tuple[str, int] | str: The server address to connect to.
        :param accounts: Accounts: The loaded signal accounts.\\ll
        :param callback: tuple[Callable, Optional[list[Any] | tuple[Any, ...]]]: The call back to call for status
            updates.
        """
        # Super the thread.
        super().__init__(None)
        logger: logging.Logger = logging.getLogger(__name__ + '.' + self.__init__.__name__)

        if not isinstance(server_address, (tuple, str)):
            logger.critical("Raising TypeError:")
            __type_error__('server_address', 'tuple[str, int] | str', server_address)

        if not isinstance(accounts, Accounts):
            logger.critical("Raising TypeError:")
            __type_error__('accounts', "Accounts", accounts)

        if not __type_check_callback__(callback)[0]:
            logger.critical("Raising TypeError:")
            __type_error__("callback", "tuple[Callable, Optional[list[Any] | tuple[Any, ...]]]",
                           callback)

        # Private properties:
        self._accounts: Accounts = accounts
        """The loaded accounts object."""
        self._callback: Optional[tuple[Callable, Optional[list[Any] | tuple[Any, ...]]]] = callback
        """The call back to run."""
        self._qrencode_exec_path: Optional[str] = __find_qrencode__()
        """The exec path of qrencode utility."""
        self._link_uri: Optional[str] = None
        """The link uri generated by signal."""
        self._text_qr: Optional[str] = None
        """The generated text qr-code."""
        self._png_qr_file_path: Optional[str] = None
        """The generated png qr-code file path."""
        self._doing_cancel: bool = False
        """Are we in the middle of canceling?"""
        self._complete: bool = False
        """Is the link process complete?"""
        # Create and connect to the link socket:
        self._link_socket: socket.socket = __socket_create__(server_address)
        """The socket to run the link process on."""
        __socket_connect__(self._link_socket, server_address)
        return

    def __call_callback__(self,
                          status: LinkAccountCallbackStates,
                          data: Optional[tuple[Optional[str], Optional[str]] | str | Account],
                          ) -> Optional[Any]:
        """
        Call the callback with the given status and data.
        :param status: LinkCallbackStates: The callback status codes.
        :param data: Optional[str | Account],
        :return: Optional[Any]: The return value of the callback.
        """
        return __run_callback__(self._callback, status.value, data)

    def start(self,
              gen_text_qr: bool = True,
              png_qr_file_path: Optional[str] = None,
              device_name: Optional[str] = None
              ) -> None:
        """
        Start the linking process.
        :param gen_text_qr: bool: Should we generate a text qr-code?
        :param png_qr_file_path: Optional[str]: Path to the png qr-code file. If None, the qr-code is not generated.
        :param device_name: Optional[str]: The device name. If None, the default set by signal-cli is used.
        :return: None.
        """
        # Setup logging:
        logger: logging.Logger = logging.getLogger(__name__ + '.' + self.start.__name__)

        # Run type checks:
        if not isinstance(gen_text_qr, bool):
            logger.critical("Raising TypeError:")
            __type_error__("gen_text_qr", "bool", gen_text_qr)
        if png_qr_file_path is not None and not isinstance(png_qr_file_path, str):
            logger.critical("Raising TypeError:")
            __type_error__("png_qr_file_path", "Optional[str]", png_qr_file_path)
        if device_name is not None and not isinstance(device_name, str):
            logger.critical("Raising TypeError:")
            __type_error__("device_name", "Optional[str]", device_name)

        # Check if the socket has been used up:
        if self._doing_cancel or self._complete:
            error_message: str = "Socket has been closed."
            logger.critical("Raising RuntimeError(%s)." % error_message)
            raise RuntimeError(error_message)

        # Store png_qr_file_path:
        self._png_qr_file_path: Optional[str] = png_qr_file_path

        # Start by calling the callback to state we're generating the link:
        return_value: Optional[bool] = self.__call_callback__(LinkAccountCallbackStates.GENERATE_URI_START, None)
        if return_value is True:
            self.cancel()
            return

        # Create the link start request object:
        link_start_command_obj: dict[str, Any] = {
            'jsonrpc': '2.0',
            'id': 0,
            'method': 'startLink',
        }

        # Create the JSON command string:
        json_command_str: str = json.dumps(link_start_command_obj) + '\n'

        # Communicate with signal:
        __socket_send__(self._link_socket, json_command_str)
        # Receive loop:
        try:
            response_str: Optional[str] = None
            first_loop: bool = True
            while response_str is None:
                if not first_loop:
                    return_value = self.__call_callback__(LinkAccountCallbackStates.LINK_WAITING, None)
                    if return_value is True:
                        self.cancel()
                        return
                first_loop = False
                response_str = __socket_receive_non_blocking__(self._link_socket, 0.1)
        except CommunicationsError as e:
            if self._doing_cancel:
                return
            raise e

        response_obj: dict[str, Any] = __parse_signal_response__(response_str)
        __check_response_for_error__(response_obj)

        # Store the link URI:
        self._link_uri: str = response_obj['result']['deviceLinkUri']

        # Call the link generation complete:
        return_value = self.__call_callback__(LinkAccountCallbackStates.GENERATE_URI_STOP, self._link_uri)
        if return_value is True:
            self.cancel()
            return

        # Call the qr-code generate start callback:
        if self._qrencode_exec_path is not None and (gen_text_qr or self._png_qr_file_path is not None):
            return_value = self.__call_callback__(LinkAccountCallbackStates.GENERATE_QR_START, None)
            if return_value is True:
                self.cancel()
                return

        # Generate the text qr-code:
        if self._qrencode_exec_path is not None and gen_text_qr:
            command_line: list[str] = [self._qrencode_exec_path, '-o', '-', '--type=UTF8', '-m', '1', self._link_uri]
            logger.debug("Attempting to generate qr-code...")
            try:
                bytes_qr_code: bytes = subprocess.check_output(command_line)
                text_qr_code: str = bytes_qr_code.decode('UTF8')
                # Add missing border to qr-code:
                border_string: str = '\u2584' * len(text_qr_code.splitlines(keepends=False)[0])
                self._text_qr = border_string + text_qr_code
                logger.debug("text qr-code successfully generated.")
            except subprocess.CalledProcessError:
                error_message: str = "Failed to generate UTF8 qr-code."
                logger.critical("Raising RuntimeError(%s)." % error_message)
                raise RuntimeError(error_message)

        # Generate the png qr-code:
        if self._qrencode_exec_path is not None and self._png_qr_file_path is not None:
            logger.debug("Attempting to generate png qr-code.")
            try:
                subprocess.check_call([self._qrencode_exec_path, '-o', self._png_qr_file_path, self._link_uri])
                logger.debug("Successfully generated png qr-code.")
            except subprocess.CalledProcessError:
                error_message: str = "Failed to generate png qr-code."
                logger.warning("Raising RuntimeError(%s)." % error_message)
                raise RuntimeError(error_message)

        # Call the qr-code generate finished callback:
        if self._qrencode_exec_path and (gen_text_qr or png_qr_file_path is not None):
            return_value = self.__call_callback__(LinkAccountCallbackStates.GENERATE_QR_STOP, (self._text_qr,
                                                                                               self._png_qr_file_path))
            if return_value is True:
                self.cancel()
                return

        # Create the finish link command object:
        link_finish_command_obj: dict[str, Any] = {
            'jsonrpc': '2.0',
            'id': 1,
            'method': 'finishLink',
            'params': {
                'deviceLinkUri': self._link_uri,
            }
        }
        if device_name is not None:
            link_finish_command_obj['params']['deviceName'] = device_name

        # Create the JSON command string:
        json_command_str = json.dumps(link_finish_command_obj) + '\n'

        # Send the command to signal:
        __socket_send__(self._link_socket, json_command_str)

        # Call the call back for finish started:
        return_value = self.__call_callback__(LinkAccountCallbackStates.FINISH_START, None)
        if return_value is True:
            self.cancel()
            return

        # Wait for signal response:
        response_str = None
        try:
            first_loop: bool = True
            while response_str is None:
                if not first_loop:
                    return_value = self.__call_callback__(LinkAccountCallbackStates.LINK_WAITING, None)
                    if return_value is True:
                        self.cancel()
                        return
                first_loop = False
                response_str = __socket_receive_non_blocking__(self._link_socket, 0.1)
        except CommunicationsError as e:
            if self._doing_cancel:
                return
            raise e
        response_obj = __parse_signal_response__(response_str)

        # Check for error:
        error_occurred, signal_code, signal_message = __check_response_for_error__(response_obj, [-1, -2, -3])
        if error_occurred:
            if signal_code == -1:
                self.__call_callback__(LinkAccountCallbackStates.LINK_EXISTS_ERROR, signal_message)
            elif signal_code == -2:
                self.__call_callback__(LinkAccountCallbackStates.LINK_UNKNOWN_ERROR, signal_message)
            elif signal_code == -3:
                self.__call_callback__(LinkAccountCallbackStates.LINK_TIMEOUT_ERROR, signal_message)
            self.cancel()
            return

        # Link successful:
        linked_number: str = response_obj['result']['number']
        logger.debug("Link successful for account: %s" % linked_number)

        new_accounts = self._accounts.__sync__()
        if len(new_accounts) == 0:
            error_message: str = "Unable to find new account."
            logger.critical("Raising RuntimeError(%s)." % error_message)
            raise RuntimeError(error_message)

        # Call callback with success, and account.
        self.__call_callback__(LinkAccountCallbackStates.LINK_SUCCESS, new_accounts[0])
        __socket_close__(self._link_socket)
        self._complete = True
        return

    def cancel(self) -> None:
        """
        Cancel a currently running link.
        :return: None.
        """
        self._doing_cancel = True
        __socket_close__(self._link_socket)
        return
